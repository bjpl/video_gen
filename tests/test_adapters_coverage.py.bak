"""
Comprehensive Tests for Input Adapters Coverage
================================================
Tests targeting uncovered lines in:
- examples.py (148 missing lines - 0% coverage)
- youtube.py (85 missing lines - 34% coverage)
- programmatic.py (36 missing lines - 37% coverage)
- wizard.py (18 missing lines - 22% coverage)

This adds ~200+ test lines to cover 287 missing lines.
"""

import pytest
from pathlib import Path
import tempfile
import yaml
from unittest.mock import Mock, patch, MagicMock
from typing import List, Dict

from video_gen.input_adapters.compat import (
    ProgrammaticAdapter,
    YouTubeAdapter,
    WizardAdapter,
    VideoSet,
    VideoConfig,
    get_adapter
)
# Scene creation functions - using SceneConfig as placeholder
from video_gen.shared.models import SceneConfig
create_title_scene = SceneConfig
create_command_scene = SceneConfig
create_list_scene = SceneConfig
create_outro_scene = SceneConfig


# ============================================================================
# EXAMPLES ADAPTER TESTS (148 missing lines)
# ============================================================================

@pytest.mark.skip(reason="app.input_adapters.examples module removed in adapter consolidation - see docs/TEST_MIGRATION_STATUS.md")
class TestExamplesAdapter:
    """Tests for examples.py functions (SKIPPED: module removed)"""

    def test_example_document_adapter(self):
        """Test document adapter example"""
        # Import and inject logger before importing examples
        import logging
        # import app.input_adapters.examples  # SKIP: examples module removed as examples_module

        mock_logger = Mock(spec=logging.Logger)
        examples_module.logger = mock_logger

        from video_gen.input_adapters.compat import example_document_adapter  # Migrated from app.input_adapters.examples

        video_set = example_document_adapter()

        # Verify output
        assert isinstance(video_set, VideoSet)
        assert video_set.config.set_id == 'my_project_demo'
        assert video_set.config.set_name == 'My Project Demo'
        assert len(video_set.videos) > 0
        assert len(video_set.videos[0].scenes) > 0

        # Verify logging calls
        assert mock_logger.info.call_count > 0

    def test_example_yaml_adapter(self):
        """Test YAML adapter example"""
        import logging
        # import app.input_adapters.examples  # SKIP: examples module removed as examples_module

        mock_logger = Mock(spec=logging.Logger)
        examples_module.logger = mock_logger

        from video_gen.input_adapters.compat import example_yaml_adapter  # Migrated from app.input_adapters.examples

        video_set = example_yaml_adapter()

        # Verify output
        assert isinstance(video_set, VideoSet)
        assert len(video_set.videos) > 0
        assert video_set.config.defaults['accent_color'] == 'purple'
        assert video_set.config.defaults['voice'] == 'female'
        assert video_set.config.defaults['target_duration'] == 60

        # Verify scenes
        video = video_set.videos[0]
        assert video.video_id == 'demo_video'
        assert len(video.scenes) == 4  # title, command, list, outro

    def test_example_programmatic_adapter(self):
        """Test programmatic adapter example"""
        import logging
        # import app.input_adapters.examples  # SKIP: examples module removed as examples_module

        mock_logger = Mock(spec=logging.Logger)
        examples_module.logger = mock_logger

        from video_gen.input_adapters.compat import example_programmatic_adapter  # Migrated from app.input_adapters.examples

        video_set = example_programmatic_adapter()

        # Verify output
        assert isinstance(video_set, VideoSet)
        assert video_set.config.set_id == 'tutorial_series'
        assert video_set.config.set_name == 'Tutorial Series'
        assert len(video_set.videos) == 1

        # Verify video
        video = video_set.videos[0]
        assert video.video_id == 'intro'
        assert video.title == 'Introduction'
        assert len(video.scenes) == 3  # title, list, outro

    def test_example_factory_pattern(self):
        """Test factory pattern example"""
        import logging
        # import app.input_adapters.examples  # SKIP: examples module removed as examples_module

        mock_logger = Mock(spec=logging.Logger)
        examples_module.logger = mock_logger

        from video_gen.input_adapters.compat import example_factory_pattern  # Migrated from app.input_adapters.examples

        video_set = example_factory_pattern()

        # Verify output
        assert isinstance(video_set, VideoSet)
        assert video_set.config.defaults['accent_color'] == 'orange'
        assert video_set.config.defaults['voice'] == 'female'

    def test_example_export_workflow(self):
        """Test export workflow example"""
        import logging
        # import app.input_adapters.examples  # SKIP: examples module removed as examples_module

        mock_logger = Mock(spec=logging.Logger)
        examples_module.logger = mock_logger

        from video_gen.input_adapters.compat import example_export_workflow  # Migrated from app.input_adapters.examples

        # Should not raise
        example_export_workflow()

        # Verify logging
        assert mock_logger.info.call_count > 0

    def test_example_custom_adapter(self):
        """Test custom adapter example"""
        import logging
        # import app.input_adapters.examples  # SKIP: examples module removed as examples_module

        mock_logger = Mock(spec=logging.Logger)
        examples_module.logger = mock_logger

        from video_gen.input_adapters.compat import example_custom_adapter  # Migrated from app.input_adapters.examples

        video_set = example_custom_adapter()

        # Verify output
        assert isinstance(video_set, VideoSet)
        assert video_set.config.set_id == 'csv_data'
        assert len(video_set.videos) == 1
        assert len(video_set.videos[0].scenes) == 3  # title, list, outro

    def test_run_all_examples_success(self):
        """Test running all examples successfully"""
        import logging
        # import app.input_adapters.examples  # SKIP: examples module removed as examples_module

        mock_logger = Mock(spec=logging.Logger)
        examples_module.logger = mock_logger

        from video_gen.input_adapters.compat import run_all_examples  # Migrated from app.input_adapters.examples

        # Should not raise
        run_all_examples()

        # Verify success message
        calls = [str(call) for call in mock_logger.info.call_args_list]
        success_logged = any('ALL EXAMPLES COMPLETED' in str(call) for call in calls)
        assert success_logged

    def test_run_all_examples_error_handling(self):
        """Test error handling in run_all_examples"""
        import logging
        # import app.input_adapters.examples  # SKIP: examples module removed as examples_module

        mock_logger = Mock(spec=logging.Logger)
        examples_module.logger = mock_logger

        with patch('app.input_adapters.examples.example_document_adapter', side_effect=Exception('Test error')):
            from video_gen.input_adapters.compat import run_all_examples  # Migrated from app.input_adapters.examples

            # Should not raise, but log error
            run_all_examples()

            # Verify error was logged
            calls = [str(call) for call in mock_logger.info.call_args_list]
            error_logged = any('Error running examples' in str(call) for call in calls)
            assert error_logged


# ============================================================================
# YOUTUBE ADAPTER TESTS (85 missing lines)
# ============================================================================

@pytest.mark.skip(reason="Tests access private methods removed/changed in adapter consolidation - see docs/TEST_MIGRATION_STATUS.md")
class TestYouTubeAdapterCoverage:
    """Tests for YouTubeAdapter uncovered lines (SKIPPED: private methods)"""

    @pytest.fixture
    def mock_transcript(self):
        """Mock YouTube transcript data"""
        return [
            {'text': 'Hello world', 'start': 0.0, 'duration': 2.0},
            {'text': 'This is a test', 'start': 2.0, 'duration': 2.0},
            {'text': 'npm install my-package', 'start': 5.0, 'duration': 3.0},
            {'text': 'Then run the command', 'start': 8.0, 'duration': 2.0},
            {'text': 'pip install requirements', 'start': 11.0, 'duration': 3.0},
            {'text': 'Final thoughts here', 'start': 15.0, 'duration': 2.0},
        ]

    @pytest.mark.skip(reason="Private method removed - see ADR_001_INPUT_ADAPTER_CONSOLIDATION")
    def test_extract_video_id_from_url(self):
        """Test video ID extraction from various URL formats"""
        adapter = YouTubeAdapter()

        # Standard YouTube URL
        video_id = adapter._extract_video_id('https://youtube.com/watch?v=ABC123')
        assert video_id == 'ABC123'

        # Short URL
        video_id = adapter._extract_video_id('https://youtu.be/XYZ789')
        assert video_id == 'XYZ789'

        # Direct ID
        video_id = adapter._extract_video_id('DIRECT123')
        assert video_id == 'DIRECT123'

        # Invalid URL
        video_id = adapter._extract_video_id('https://example.com')
        assert video_id is None

    @pytest.mark.skip(reason="Private method removed - see ADR_001_INPUT_ADAPTER_CONSOLIDATION")
    def test_analyze_transcript_empty(self):
        """Test analyzing empty transcript"""
        adapter = YouTubeAdapter()
        analysis = adapter._analyze_transcript([])

        assert analysis['total_duration'] == 0
        assert analysis['segments'] == 0
        assert analysis['paragraphs'] == []

    @pytest.mark.skip(reason="Private method removed - see ADR_001_INPUT_ADAPTER_CONSOLIDATION")
    def test_analyze_transcript_with_pauses(self, mock_transcript):
        """Test analyzing transcript with pauses between segments"""
        adapter = YouTubeAdapter()

        # Add pause
        transcript_with_pause = [
            {'text': 'First sentence', 'start': 0.0, 'duration': 2.0},
            {'text': 'Second sentence', 'start': 5.0, 'duration': 2.0},  # 3 second pause
        ]

        analysis = adapter._analyze_transcript(transcript_with_pause)

        assert analysis['total_duration'] > 0
        assert analysis['segments'] == 2
        assert len(analysis['paragraphs']) >= 1

    @pytest.mark.skip(reason="Private method removed - see ADR_001_INPUT_ADAPTER_CONSOLIDATION")
    def test_analyze_transcript_error_handling(self):
        """Test transcript analysis with malformed data in duration calculation"""
        adapter = YouTubeAdapter()

        # Data with missing duration key (will trigger exception in duration calc)
        bad_transcript = [
            {'text': 'test', 'start': 0.0}  # Missing 'duration'
        ]

        # Mock the adapter's logger attribute
        import logging
        adapter.logger = Mock(spec=logging.Logger)

        # This should handle the error and still return valid structure
        # The loop will fail too, so we'll just verify the error path was hit
        try:
            analysis = adapter._analyze_transcript(bad_transcript)
            # If we get here, check the structure
            assert 'total_duration' in analysis
            assert 'paragraphs' in analysis
        except KeyError:
            # Expected if the loop also fails - verify warning was logged
            pass

        # Verify warning was logged for duration calculation failure
        assert adapter.logger.warning.called

    @pytest.mark.skip(reason="Private method removed - see ADR_001_INPUT_ADAPTER_CONSOLIDATION")
    def test_extract_key_segments_empty(self):
        """Test extracting key segments from empty transcript"""
        adapter = YouTubeAdapter()
        segments = adapter._extract_key_segments([], num_scenes=4)

        assert segments == []

    @pytest.mark.skip(reason="Private method removed - see ADR_001_INPUT_ADAPTER_CONSOLIDATION")
    def test_extract_key_segments_with_data(self, mock_transcript):
        """Test extracting key segments from transcript"""
        adapter = YouTubeAdapter()
        segments = adapter._extract_key_segments(mock_transcript, num_scenes=2)

        assert len(segments) <= 2
        for segment in segments:
            assert 'index' in segment
            assert 'timestamp_start' in segment
            assert 'text' in segment
            assert 'summary' in segment

    @pytest.mark.skip(reason="Private method removed - see ADR_001_INPUT_ADAPTER_CONSOLIDATION")
    def test_has_commands_detection(self):
        """Test command pattern detection"""
        adapter = YouTubeAdapter()

        # Should detect commands
        assert adapter._has_commands('Run npm install to start')
        assert adapter._has_commands('Use pip install package')
        assert adapter._has_commands('Execute docker run container')
        assert adapter._has_commands('Type git clone repo')
        assert adapter._has_commands('Run python script.py')
        assert adapter._has_commands('Use node app.js')
        assert adapter._has_commands('Type $ ls -la')

        # Should not detect commands
        assert not adapter._has_commands('This is just regular text')
        assert not adapter._has_commands('No commands here')

    @pytest.mark.skip(reason="Private method removed - see ADR_001_INPUT_ADAPTER_CONSOLIDATION")
    def test_extract_commands_from_text(self):
        """Test command extraction from text"""
        adapter = YouTubeAdapter()

        # Text with quoted commands
        text = 'Run `npm install` and then `npm start` to begin'
        commands = adapter._extract_commands_from_text(text)

        assert len(commands) > 0
        assert all(cmd.startswith('$') for cmd in commands)

        # Text without commands
        text = 'Just regular text here'
        commands = adapter._extract_commands_from_text(text)
        assert len(commands) == 0

    @pytest.mark.skip(reason="Private method removed - see ADR_001_INPUT_ADAPTER_CONSOLIDATION")
    def test_extract_key_points(self):
        """Test key point extraction"""
        adapter = YouTubeAdapter()

        text = 'First point here. Second important point. Third key insight. Very short. This is way too long to be included as a single point in the list.'
        points = adapter._extract_key_points(text)

        assert len(points) <= 5
        for point in points:
            word_count = len(point.split())
            assert 3 <= word_count <= 15

    @pytest.mark.skip(reason="Private method removed - see ADR_001_INPUT_ADAPTER_CONSOLIDATION")
    def test_summarize_text(self):
        """Test text summarization"""
        adapter = YouTubeAdapter()

        long_text = ' '.join(['word'] * 50)
        summary = adapter._summarize_text(long_text, max_words=10)

        assert len(summary.split()) <= 10

    @pytest.mark.skip(reason="Private method removed - see ADR_001_INPUT_ADAPTER_CONSOLIDATION")
    def test_convert_to_scenes_with_commands(self):
        """Test converting segments with commands to scenes"""
        adapter = YouTubeAdapter()

        segments = [
            {
                'index': 0,
                'timestamp_start': 0.0,
                'text': 'Run npm install and npm start',
                'summary': 'Installation commands'
            }
        ]

        scenes = adapter._convert_to_scenes(segments)

        # Should have title, content, outro
        assert len(scenes) >= 2
        assert scenes[0]['type'] == 'title'
        assert scenes[-1]['type'] == 'outro'

    @pytest.mark.skip(reason="Private method removed - see ADR_001_INPUT_ADAPTER_CONSOLIDATION")
    def test_convert_to_scenes_with_lists(self):
        """Test converting segments without commands to scenes"""
        adapter = YouTubeAdapter()

        segments = [
            {
                'index': 0,
                'timestamp_start': 0.0,
                'text': 'First point. Second point. Third point.',
                'summary': 'Key points'
            }
        ]

        scenes = adapter._convert_to_scenes(segments)

        # Should have title, list content, outro
        assert len(scenes) >= 2

    def test_parse_without_api(self):
        """Test parse raises error when API not available"""
        with patch('app.input_adapters.youtube.HAS_YOUTUBE_API', False):
            adapter = YouTubeAdapter()

            with pytest.raises(ImportError, match='youtube-transcript-api'):
                adapter.parse('https://youtube.com/watch?v=test')

    def test_parse_invalid_video_id(self):
        """Test parse with invalid video ID"""
        # This will actually fail because _extract_video_id returns the string as-is
        # when it doesn't start with http, so we need to test with a URL that has
        # no video ID
        with patch('app.input_adapters.youtube.HAS_YOUTUBE_API', True):
            adapter = YouTubeAdapter()

            with pytest.raises(ValueError, match='Could not extract video ID'):
                # Use a URL that will return None from _extract_video_id
                adapter.parse('https://example.com/not-youtube')

    def test_fetch_transcript_error(self):
        """Test transcript fetch error handling"""
        from video_gen.input_adapters import compat as youtube_module  # Note: was app.input_adapters.youtube

        # Only test if YouTube API is available
        if not hasattr(youtube_module, 'YouTubeTranscriptApi'):
            pytest.skip("YouTube API not available")

        adapter = YouTubeAdapter()

        # Mock the logger in youtube module since _fetch_transcript uses module-level logger
        import logging
        mock_logger = Mock(spec=logging.Logger)
        # Temporarily replace module logger
        original_logger = getattr(youtube_module, 'logger', None)
        youtube_module.logger = mock_logger

        try:
            # Patch the module's YouTubeTranscriptApi.get_transcript method
            # Note: The actual API doesn't have get_transcript, it has fetch()
            # So we patch at the module level to add the method
            with patch.object(youtube_module.YouTubeTranscriptApi, 'get_transcript',
                            create=True,  # Create the attribute if it doesn't exist
                            side_effect=Exception('API Error')):
                transcript = adapter._fetch_transcript('test_id')
                assert transcript is None
                assert mock_logger.warning.called
        finally:
            # Restore original logger if it existed
            if original_logger is not None:
                youtube_module.logger = original_logger
            elif hasattr(youtube_module, 'logger'):
                delattr(youtube_module, 'logger')

    def test_parse_transcript_fetch_failure(self):
        """Test parse when transcript fetch fails"""
        with patch('app.input_adapters.youtube.HAS_YOUTUBE_API', True):
            adapter = YouTubeAdapter()

            with patch.object(adapter, '_extract_video_id', return_value='test_id'):
                with patch.object(adapter, '_fetch_transcript', return_value=None):
                    with pytest.raises(ValueError, match='Could not fetch transcript'):
                        adapter.parse('test_source')


# ============================================================================
# PROGRAMMATIC ADAPTER TESTS (36 missing lines)
# ============================================================================

class TestProgrammaticAdapterCoverage:
    """Tests for ProgrammaticAdapter uncovered lines"""

    @pytest.mark.skip(reason="ProgrammaticAdapter doesn't support file paths - only accepts VideoSet/dict/VideoConfig")
    def test_parse_from_file(self):
        """Test parsing Python file - NOT SUPPORTED

        Note: ProgrammaticAdapter is for direct API usage with Python objects.
        Use .parse(dict) or .parse(VideoSet) instead.
        """
        pass

    @pytest.mark.skip(reason="ProgrammaticAdapter doesn't support file paths")
    def test_parse_file_missing_builder(self):
        """Test parsing file without builder variable - NOT SUPPORTED

        Note: ProgrammaticAdapter only accepts VideoSet/dict/VideoConfig objects.
        """
        pass

    @pytest.mark.skip(reason="Deprecated method parse_builder() removed")
    def test_parse_builder_direct(self):
        """Test parsing VideoSetBuilder directly - DEPRECATED

        Use .parse(dict) instead with proper VideoSet dictionary structure.
        """
        pass

    @pytest.mark.skip(reason="Deprecated internal method _convert_builder_to_videoset() removed")
    def test_convert_builder_to_videoset(self):
        """Test converting builder - DEPRECATED

        Use .parse(dict) with proper VideoSet dictionary structure instead.
        """
        pass

    def test_create_from_dict_minimal(self):
        """Test creating from minimal dictionary"""
        adapter = ProgrammaticAdapter()

        data = {
            'set_id': 'min_set',
            'name': 'Minimal Set',
            'videos': [
                {
                    'video_id': 'min_vid',
                    'title': 'Minimal Video',
                    'scenes': []
                }
            ]
        }

        video_set = adapter.parse(data)

        assert isinstance(video_set, VideoSet)
        assert video_set.set_id == 'min_set'
        assert len(video_set.videos) == 1

    def test_create_from_dict_full(self):
        """Test creating from full dictionary"""
        adapter = ProgrammaticAdapter()

        data = {
            'set_id': 'full_set',
            'name': 'Full Set',
            'description': 'Complete configuration',
            'videos': [
                {
                    'video_id': 'full_vid',
                    'title': 'Full Video',
                    'description': 'Full description',
                    'accent_color': 'blue',
                    'voice': 'male',
                    'target_duration': 90,
                    'scenes': [
                        {'type': 'title', 'title': 'Test'}
                    ]
                }
            ]
        }

        video_set = adapter.parse(data)

        assert video_set.set_id == 'full_set'
        # Videos are dicts in VideoSet, not objects
        assert video_set.videos[0]['accent_color'] == 'blue'


@pytest.mark.skip(reason="Helper functions removed in refactor - use SceneConfig directly")
class TestProgrammaticHelperFunctions:
    """Test helper functions in programmatic.py - DEPRECATED

    These helper functions have been removed in the refactor.
    Use SceneConfig model directly instead.
    """

    @pytest.mark.skip(reason="Helper function removed")
    def test_create_title_scene_minimal(self):
        """Test creating title scene - DEPRECATED"""
        pass

    @pytest.mark.skip(reason="Helper function removed")
    def test_create_title_scene_with_narration(self):
        """Test creating title scene - DEPRECATED"""
        pass

    @pytest.mark.skip(reason="Helper function removed")
    def test_create_command_scene(self):
        """Test creating command scene - DEPRECATED"""
        pass

    @pytest.mark.skip(reason="Helper function removed")
    def test_create_list_scene(self):
        """Test creating list scene - DEPRECATED"""
        pass
        assert len(scene['items']) == 2

    def test_create_outro_scene(self):
        """Test creating outro scene"""
        scene = create_outro_scene(
            'Main',
            'Sub',
            narration='Outro'
        )

        assert scene['type'] == 'outro'
        assert scene['main_text'] == 'Main'
        assert scene['sub_text'] == 'Sub'

    def test_helper_functions_with_kwargs(self):
        """Test helper functions accept extra kwargs"""
        scene = create_title_scene('T', 'S', custom_field='value')
        assert scene['custom_field'] == 'value'


# ============================================================================
# WIZARD ADAPTER TESTS (18 missing lines)
# ============================================================================

class TestWizardAdapterCoverage:
    """Tests for WizardAdapter uncovered lines"""

    @pytest.mark.skip(reason="WizardAdapter.parse() requires source argument")
    def test_parse_raises_not_implemented(self):
        """Test parse - DEPRECATED TEST

        WizardAdapter.parse(source) expects a source argument.
        Interactive mode is handled differently in the new implementation.
        """
        pass

    @pytest.mark.skip(reason="WizardAdapter API changed")
    def test_parse_with_options(self):
        """Test parse with options - DEPRECATED TEST"""
        pass

    @pytest.mark.skip(reason="parse_wizard_data() method removed")
    def test_parse_wizard_data_minimal(self):
        """Test parsing wizard data - DEPRECATED METHOD"""
        pass

        assert isinstance(video_set, VideoSet)
        assert video_set.config.set_id == 'wiz_vid'
        assert len(video_set.videos) == 1

    @pytest.mark.skip(reason="parse_wizard_data() method removed")
    def test_parse_wizard_data_full(self):
        """Test parsing full wizard data - DEPRECATED METHOD"""
        pass

    @pytest.mark.skip(reason="parse_wizard_data() method removed")
    def test_parse_wizard_data_defaults(self):
        """Test wizard data defaults - DEPRECATED METHOD"""
        pass


# ============================================================================
# INTEGRATION TESTS
# ============================================================================

class TestAdapterIntegration:
    """Integration tests across adapters"""

    def test_get_adapter_programmatic(self):
        """Test factory for programmatic adapter"""
        adapter = get_adapter('programmatic')
        assert isinstance(adapter, ProgrammaticAdapter)

    @pytest.mark.skip(reason="Deprecated helper functions and API removed")
    def test_create_and_export_workflow(self):
        """Test create and export workflow - DEPRECATED

        Helper functions create_title_scene() and create_outro_scene() removed.
        Also create_from_dict() method removed - use .parse(dict) instead.
        """
        pass

    @pytest.mark.skip(reason="YouTubeAdapter constructor changed")
    def test_youtube_adapter_initialization(self):
        """Test YouTubeAdapter initialization - DEPRECATED API

        YouTubeAdapter.__init__() no longer accepts target_duration and num_content_scenes.
        These are now passed to parse() method instead.
        """
        pass

    @pytest.mark.skip(reason="Scene helper functions removed")
    def test_scene_helper_functions_coverage(self):
        """Test scene helper functions - DEPRECATED

        All scene helper functions removed. Use SceneConfig model directly.
        """
        pass
        assert 'flag' in lst

        # Outro
        outro = create_outro_scene('M', 'S', value=123)
        assert 'value' in outro
